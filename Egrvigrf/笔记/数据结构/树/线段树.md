

## 线段树

时间复杂度
建树:$O(n)$
区间查询:$O(logn)$
区间修改:$O(logn)$

线段树是一种二叉树，比原数组多的节点用来存储对应原数组的某个区间的信息，通过这些节点显著降低了区间查询和修改的时间复杂度，有一些地方是“幽灵节点” ,这些节点从不使用但被编号以保证真节点能通过下标$2*p$和$2*p+1$访问到子节点，浪费了一些空间，且最大不会超过原数组的大小的4倍。

### 证明：建树时开4倍原数组大小
线段树的最下层存放的是数组的真实值，所以最下层的节点数为$2^{\lceil \log_2 n \rceil}$，所有节点数量用等比数列求和公式得到
转换为证明$2^{\lceil \log_2 n \rceil + 1} - 1 \leq 4n$

证明：
我们需要证明不等式 $2^{\lceil \log_2 n \rceil + 1} - 1 \leq 4n$。

1. $\lceil \log_2 n \rceil$ 是 $n$ 的以 2 为底的对数向上取整。
   这意味着 $ \lceil \log_2 n \rceil $ 是使得 $2^{\lceil \log_2 n \rceil} \geq n$ 的最小整数。
   因此，$\log_2 n \leq \lceil \log_2 n \rceil < \log_2 n + 1$。

2. 因此，$2^{\log_2 n} \leq 2^{\lceil \log_2 n \rceil} < 2^{\log_2 n + 1}$，即
   $n \leq 2^{\lceil \log_2 n \rceil} < 2n$。

3. 乘以2得到：
   $2n \leq 2^{\lceil \log_2 n \rceil + 1} < 4n$。

4. 所以，$2^{\lceil \log_2 n \rceil + 1} \leq 4n$。

5. 减去1得：
   $2^{\lceil \log_2 n \rceil + 1} - 1 < 4n$。

因此，得证 $2^{\lceil \log_2 n \rceil + 1} - 1 \leq 4n$。


#### 建树
递归
后序遍历二叉树，建好左右子树后再存根的值为要维护的东西

#### 懒标记
新建一下数组用于存放懒信息
如果能不更新就不更新，必须更新时只往下更新一层。


线段树常见方法一览
void up(i..) : 根据子范围的查询信息，把父范围的查询信息更新正确
void down(i..) : 父范围的懒信息，往下只下发一层，给左范围、右范围，然后父范围的懒信息清空
void lazy(i..) : 当前范围被修改任务全覆盖时 或 父范围发下来的懒更新时，信息数组们如何修改
void build(l, r, i)  : 建树
void update(jobl, jobr, jobv, l, r, i) : 范围上数值的重置任务
void add(jobl, jobr, jobv, l, r, i) : 范围上数值的增加任务
int query(jobl, jobr, l, r, i) : 范围上的信息查询任务


要求区间修改，区间查询
[洛谷](https://www.luogu.com.cn/problem/P3372)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2e5+1;
int a[N];
int sum[N<<2];
int add[N<<2];

void up(int p) {
    sum[p] = sum[p << 1] + sum[p << 1 | 1];
}

void lazy(int p, int v, int n) {
    sum[p] += v * n;
    add[p] += v;
}

void build(int p, int l, int r) {
    if (l == r) {
        sum[p] = a[l];
        return;
    }
    int mid = (l + r) >> 1;
    build(p << 1, l, mid);
    build(p << 1 | 1, mid + 1, r);
    add[p] = 0;
    up(p);
}

void down(int p, int ln, int rn) {
    if (add[p] != 0) {
        lazy(p << 1, add[p], ln);
        lazy(p << 1 | 1, add[p], rn);
        add[p] = 0;
    }
}

void change(int al, int ar, int v, int p, int l, int r) {
    if (al <= l && r <= ar) {
        lazy(p, v, r - l + 1);
    } else {
        int mid = (l + r) >> 1;
        down(p, mid - l + 1, r - mid);
        if (al <= mid) {
            change(al, ar, v, p << 1, l, mid);
        }
        if (mid + 1 <= ar) {
            change(al, ar, v, p << 1 | 1, mid + 1, r);
        }
        up(p);
    }
}

int query(int ql, int qr, int p, int l, int r) {
    if (ql <= l && r <= qr) {
        return sum[p];
    }
    int mid = (l + r) >> 1;
    down(p, mid - l + 1, r - mid);
    int cnt = 0;
    if (mid >= ql) {
        cnt += query(ql, qr, p << 1, l, mid);
    }
    if (mid + 1 <= qr) {
        cnt += query(ql, qr, p << 1 | 1, mid + 1, r);
    }
    return cnt;
}

signed main() {
    int n,m;
    cin >> n >> m;
    for(int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    build(1,1,n);
    int op,x,y,v;
    for(int i = 1; i <= m; i++) {
        cin >> op;
        if(op == 1) {
            cin >> x >> y >> v;
            change(x,y,v,1,1,n);
        } else if(op == 2) {
            cin >> x >> y;
            cout<<query(x,y,1,1,n)<<endl;
        }
    }
    return 0;
}
```

要求区间重置，区间查询
add数组改为用于记录重置值的数组，新增一个bool数组来记录节点处是否要进行重置操作，
同样也是懒更新
为什么要多一个数组，因为不能用0来标记，无法区分是重置为0还是不进行重置

```cpp
void lazy(int p, int v, int n) {
    sum[p] = v * n; //+= 改为=
    change[p] = v;
    is_change[p] = true;
}
```

```cpp
void down(int p, int ln, int rn) {
    if (is_change[p]) {
        lazy(p << 1, change[p], ln);
        lazy(p << 1 | 1, change[p], rn);
        is_change[p] = 0;
    }
}
```

维护最大/小值
up()函数修改
query函数修改返回最大值

如果要同时进行区间修改和区间重置操作，则要注意优先级,reset后cnt不要忘记清零
如果后重置无视先前修改，如果重置后再修改则要进行两次更新
[洛谷](https://www.luogu.com.cn/problem/solution/P1253)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define IOS ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr)
#define endl '\n'
#define int long long 
const int N = 1e6 + 1;
int a[N];
int mx[N << 2];
int change[N << 2];
bool is_change[N << 2];
int cnt[N << 2];
#define inf 0x3f3f3f3f // 1e9
void up(int p) {
    mx[p] = max(mx[p << 1], mx[p << 1 | 1]);
}
void build(int p, int l, int r) {
    if (l == r) {
        mx[p] = a[l];
    } else {
        int mid = (l + r) >> 1;
        build(p << 1, l, mid);
        build(p << 1 | 1, mid + 1, r);
        up(p);
    }
    is_change[p] = false;
    cnt[p] = 0;
}

void addlazy(int p, int v) {
    mx[p] += v;
    cnt[p] += v;
}

void resetlazy(int p, int v) {
    mx[p] = v;
    change[p] = v;
    is_change[p] = true;
    cnt[p] = 0;
}

void down(int p) {
    if (is_change[p]) {
        resetlazy(p << 1, change[p]);
        resetlazy(p << 1 | 1, change[p]);
        is_change[p] = false;
    }
    if (cnt[p] != 0) {
        addlazy(p << 1, cnt[p]);
        addlazy(p << 1 | 1, cnt[p]);
        cnt[p] = 0;
    }
}

void add(int al, int ar, int v, int p, int l, int r) {
    if (al <= l && r <= ar) {
        addlazy(p, v);
    } else {
        down(p);
        int mid = (l + r) >> 1;
        if (mid >= al) {
            add(al, ar, v, p << 1, l, mid);
        }
        if (mid + 1 <= ar) {
            add(al, ar, v, p << 1 | 1, mid + 1, r);
        }
        up(p);
    }
}


void reset(int rl, int rr, int v, int p, int l, int r) {
    if (rl <= l && r <= rr) {
        resetlazy(p, v);
    } else {
        down(p);
        int mid = (l + r) >> 1;
        if (mid >= rl) {
            reset(rl, rr, v, p << 1, l, mid);
        }
        if (mid + 1 <= rr) {
            reset(rl, rr, v, p << 1 | 1, mid + 1, r);
        }
        up(p);
    }
}

int query(int ql, int qr, int p, int l, int r) {
    if (ql <= l && r <= qr) {
        return mx[p];
    } else {
        down(p);
        int M = LONG_LONG_MIN;
        int mid = (l + r) >> 1;
        if (mid >= ql) {
            M = max(M, query(ql, qr, p << 1, l, mid));
        }
        if (mid + 1 <= qr) {
            M = max(M, query(ql, qr, p << 1 | 1, mid + 1, r));
        }
        return M;
    }
}
signed main() {
    IOS;
    int n, q;
    cin >> n >> q;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    build(1, 1, n);
    int op, l, r, x;
    for (int i = 1; i <= q; i++) {
        cin >> op;
        if (op == 1) {
            cin >> l >> r >> x;
            reset(l, r, x, 1, 1, n);
        } else if (op == 2) {
            cin >> l >> r >> x;
            add(l, r, x, 1, 1, n);
        } else if (op == 3) {
            cin >> l >> r;
            cout << query(l, r, 1, 1, n) << endl;
        }
    }
    return 0;
}

/**
 * author:  Egrvigrf
 * created: 2024-07-23 13:54
**/
```
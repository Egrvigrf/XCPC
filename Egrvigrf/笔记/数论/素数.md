判断素数
$O(sqrt(n))$
判过i后n/i及以后就不用判断了
所以判断过根号n，之后就不用判断了
```cpp
bool f = true;
for(int i = 2; i * i <= n; i++) {
	if(x%i ==0) {
		f = false;
	}
}
```

求一个数的质因数
```cpp
vector<int> ans;
for(int i = 2; i*i <= x; i++) {
	if(x % i == 0) {
		ans.pushback(i);
		while(x % i == 0) x /= i;
	}
}
if(x > 1) {
	ans.pushback(x);
}
```

Miller-Rabin判断大素数
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef __int128 ll;
typedef pair<int, int> pii;

template<typename T> inline T read() {
    T x = 0, f = 1; char ch = 0;
    for(; !isdigit(ch); ch = getchar()) if(ch == '-') f = -1;
    for(; isdigit(ch); ch = getchar()) x = (x << 3) + (x << 1) + (ch - '0');
    return x * f;
}

template<typename T> inline void write(T x) {
    if(x < 0) putchar('-'), x = -x;
    if(x > 9) write(x / 10);
    putchar(x % 10 + '0');
}

template<typename T> inline void print(T x, char ed = '\n') {
    write(x), putchar(ed);
}

ll t, n;

ll qpow(ll a, ll b, ll mod) {
    ll ret = 1;
    while(b) {
        if(b & 1) ret = (ret * a) % mod;
        a = (a * a) % mod;
        b >>= 1;
    }
    return ret % mod;
}

vector<ll> p = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37};

bool miller_rabin(ll n) {
    if(n < 3 || n % 2 == 0) return n == 2;
    ll u = n - 1, t = 0;
    while(u % 2 == 0) u /= 2, ++ t;
    for(auto a : p) {
        if(n == a) return 1;
        if(n % a == 0) return 0;
        ll v = qpow(a, u, n);
        if(v == 1) continue;
        ll s = 1;
        for(; s <= t; ++ s) {
            if(v == n - 1) break;
            v = v * v % n;
        }
        if(s > t) return 0; 
    }
    return 1;
}

int main() {
    t = read<ll>();
    while(t --) {
        n = read<ll>();
        if(miller_rabin(n)) puts("Yes");
        else puts("No");
    }
    return 0;
}
```


# 埃氏筛
先假设假设1-n所有数都是素数
从2开始筛
小于调和级数O(n*log(n))
时间复杂度O(n*log(logn))
```cpp
ll countPrimes(ll n) {
    bool vis[n + 1];
    for (int i = 0; i <= n; i++) vis[i] = false;
    for (ll i = 2; i <= n; i++) {
        if (!vis[i]) {
            for (ll j = i * i; j <= n; j += i) {
                vis[j] = true;
            }
        }
    }
    ll cnt = 0;
    for (ll i = 2; i <= n; i++) {
        if (!vis[i]) {
            cnt++;
        }
    }
    return cnt;
}
```

如果只是计数可以优化
```cpp
int countPrimes(int n) {
    if (n <= 1) {
        return 0;
    }
    // vis[i] = true，代表i是合数
    // vis[i] = false，代表i是质数
    // 初始时认为0~n所有数都是质数
    bool vis[n + 1];
    memset(vis,0,sizeof(vis));
    // 先把所有的偶数去掉，但是算上2
    // 估计的质数数量，如果发现更多合数，那么cnt--
    int cnt = (n + 1) / 2;
    for (int i = 3; i * i <= n; i += 2) {
        if (!vis[i]) {
            for (int j = i * i; j <= n; j += 2 * i) {
                if (!vis[j]) {
                    vis[j] = true;
                    cnt--;
                }
            }
        }
    }
    return cnt;
}
```

# 欧拉筛
每个合数只被最小的质数筛一次
O(n)时间复杂度
常数时间比埃氏筛还大
```cpp
ll countPrimes(ll n) {
    int prime[n / 2 + 1];
    bool vis[n + 1];
    for (int i = 2; i < n; i++) {
        vis[i] = false;
    }
    int cnt = 0;
    for (int i = 2; i < n; i++) {
        if (!vis[i]) {
            prime[cnt++] = i;
        }
        for (int j = 0; j < cnt; j++) {
            if (i * prime[j] >= n) {
                break;
            }
            vis[i * prime[j]] = true;
            if (i % prime[j] == 0) {
                break;
            }
        }
    }
    return cnt;
}
```
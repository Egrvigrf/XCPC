# 杂项
## login

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
#define inf 0x3f3f3f3f 
#define LOCAL
#ifdef LOCAL
#define dbg(...) _((char *)#__VA_ARGS__,__VA_ARGS__)
#else 
#define dbg(...) ((void)0)
#endif
template<typename T, typename... A>
void _(char* f, T x, A... y) {
    while (*f && *f != ',') cout << *f++;
    cout << '=' << x << (sizeof...(y) ? ", " : "\n");
    if constexpr (sizeof...(y) > 0) _(f + 1, y...);
}

void solve() {
    
}

int main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int T; cin >> T;
    while (T--) solve();
    return 0;
}
```

## 快读

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read(){
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-'){w=-1;}ch=getchar();}
    while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
    return s*w;
}
inline void write(int x){
    if(x<0){putchar('-');x=-x;}
    if(x>9){write(x/10);}
    putchar(x%10+'0');
}
#define TIME  (1.0 * clock() / CLOCKS_PER_SEC)
#define file(name)  if (fopen(name".inp", "r")) { freopen(name".inp", "r", stdin); freopen(name".out", "w", stdout); }
int main()
{
    //int n = read();
    for(int i = 1; i <= 100000; i++)
        cout<<i;
    cerr << "Time elapsed: " << TIME << " s.\n";
    return 0;
}
```

## int128

```cpp
using i128 = __int128_t;
auto& operator>>(istream& it, __int128_t& j) {
    string val;
    it >> val;
    reverse(val.begin(), val.end());
    __int128_t ans = 0;
    bool f = 0;
    char c = val.back();
    val.pop_back();
    for (; c < '0' || c > '9'; c = val.back(), val.pop_back()) {
        if (c == '-') {
            f = 1;
        }
    }
    for (; c >= '0' && c <= '9'; c = val.back(), val.pop_back()) {
        ans = ans * 10 + c - '0';
    }
    j = f ? -ans : ans;
    return it;
}
auto& operator<<(ostream& os, const __int128_t& j) {
    string ans;
    function<void(__int128_t)> write = [&](__int128_t x) {
        if (x < 0) ans += '-', x = -x;
        if (x > 9) write(x / 10);
        ans += x % 10 + '0';
        };
    write(j);
    return os << ans;
}
```


## 一些STL

对 vector 进行去重
`sort(vec.begin(), vec.end());`
`vec.erase(unique(vec.begin(), vec.end()), vec.end());`
//或者
`sort(vec.begin(), vec.end());`
`vec.resize(unique(vec.begin(), vec.end()) - vec.begin());`

对于 unique 函数来说，要求元素必须是相邻的才能进行去重操作，而且它只会去除相邻的重复元素。  
因此，在使用 unique 去重之前，通常需要先对容器进行排序，以确保相同的元素都相邻排列，才能正确去重

## 前缀和
预处理后可以用O(1)的时间复杂度求一个区间的值
能显著降低查询时间复杂度
### 一维
(从原数组)构建
```cpp
a[0] = 0;
for(int i = 1;i <= n; i++) {
	a[i] += a[i-1];
}
```
查询\[l,r]区间的和
`a[r] - a[l-1]` 
``
### 二维
求一个矩形区域的所有值的和
(从原数组)构建
```cpp
for(int i = 0; i <= m; i++) sum[0][i] = 0;
for(int i = 0; i <= n; i++) sum[i][0] = 0;
for(int i = 1; i <= n; i++) {
	for(int j = 1; i <= m; j++) {
		sum[i][j] += sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1];
	}
}
```

查询(x1,y1)和(x2,y2)包裹的矩形区域内的和
```cpp
int query(int x1 ,int y1 ,int x2, int y2) {
    return sum[x2][y2] - sum[x2][y1-1] - sum[x1-1][y2] + sum[x1-1][y1-1];
}
```

## 差分

### 一维
不支持边操作边查询
数组$a$在一个区间$[l,r]$上每个位置都增加相同的值$x$
如果$a[i] = x$;
含义是，无限远的数轴上从i位置(包括)开始，每个位置的值变化$x$ 
可用差分数组标记
```cpp
a[l] += x;
a[r+1] -= x;
```
求前缀和即可得到每一位的值

### 等差序列差分

s    d-s        0          0       ...    0     -e-d    e
s      d         d          d       ...    d      -e      0     
s    s+d    s+2d    s+3d    ...    e        0      0  

进行标记
```cpp
void op(int l, int r, int s, int e,int d) {
    ans[l] += s;
    ans[l + 1] += d - s;
    ans[r + 1] += -e - d;
    ans[r + 2] += e;
}
```
求两次前缀和即可

### 二维差分
$sum$数组在(x1,y1)和(x2,y2)包裹的矩形区域内每个sum\[i]\[j]的值增加v。
如果`sum[x][y] = v`，那么大于等于$i >= x,j >= y$的位置的点所有点`sum[i][j]`的值都增加v
```cpp
void add(int x1, int y1, int x2, int y2, int v) {
    sum[x1][y1] += v;
    sum[x2 + 1][y2 + 1] += v;
    sum[x2 + 1][y1] -= v;
    sum[x1][y2 + 1] -= v;
}
```
之后再求一遍二维前缀和就可以得到每个点的值

## 二分
```cpp
while (l <= r) {
    int mid = (l + r) / 2;
    if (check(mid)) {
        r = mid - 1;
        ans = mid;
    } else {
        l = mid + 1;
    }
}
```

## 三分
# 图论

## 建图

### 链式前向星

有n个点，m条边（无向图开双倍）
cnt：边号
e\[cnt].to ：与第cnt条边相连的边
e\[cnt].to ：第cnt条边的邻边
e\[cnt].w  ：第cnt条边的权值
head\[x]   ：点x的头边号
```cpp
int cnt = 1;
int head[MAXN];
int to[MAXM]; //无向图开双倍
int nx[MAXM]; //无向图开双倍
int w[MAXM];  //无向图开双倍
```
多组数据一定要初始化head和cnt
to,nx,w数组由cnt控制，所以只要cnt重置为1即可

```cpp
memset(head,0,sizeof(head));
cnt = 1;
```

添加边
```cpp
void addedge(int x,int y,int v) {
    w[cnt] = v; 
    to[cnt] = y;
    nx[cnt] = head[x]; 
    head[x] = cnt++; //添加的过程不断更新链表的头部，对于一个节点，最后添加的边是链表头。
}
```

遍历和点x所连接的所有边
```cpp
for(int i = head[x]; i > 0; i = nx[i]) {
    int t = to[i];
}
```

### 邻接表
```cpp
const int N = 2e5+1;
vector<pair<int,int> > adj[N];
void addedge(int x,int y,int v) {
    adj[x].push_back(make_pair(y,v));
    //adj[y].push_back(make_pair(x,v));
}
for(auto& i : adj[x]) {
    int t = i.first;
}
```
## Dijkstra
```cpp
#include <bits/stdc++.h>
using namespace std;
const long long inf = 2147483647;
struct edge {
    int to, next, w;
} e[1001000];
int cnt = 0;
int head[1001000];
void addedge(int x, int y, int v) {
    e[++cnt].next = head[x];
    e[cnt].to = y;
    e[cnt].w = v;
    head[x] = cnt;
}
struct priority {
    int dis;
    int id;
    bool operator <(const priority& x)const {
        return x.dis < dis;
    }
};
int main() {
    ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);//数据多加快读
    int n, m, s; // 三个整数n,m,s分别表示点的个数、有向边的个数、出发点的编号
    cin >> n >> m >> s;
    long long dist[n + 1];
    bool is_visit[n + 1];
    for (int i = 1; i <= n; i++) {
        dist[i] = inf;
        is_visit[i] = false;
    }
    dist[s] = 0;
    /*使用前向星*/
    for (int i = 1; i <= m; i++) {
        int begin, end, v;
        cin >> begin >> end >> v;
        addedge(begin, end, v);
    }
    priority_queue<priority> q;
    q.push((priority) {0,s});
    while (!q.empty()) {
        priority temp = q.top();
        q.pop();
        if(is_visit[temp.id]) continue;
        is_visit[temp.id] = true;
        int cur = temp.id;
        for (int j = head[cur]; j != 0; j = e[j].next) {
            int to = e[j].to;
            if (!is_visit[to] && dist[cur] + e[j].w < dist[to]) {
                dist[to] = dist[cur] + e[j].w;
                q.push((priority){dist[to],to});
            }
        }
    }
    for (int i = 1; i <= n; i++) 
        cout << dist[i] << " ";
    return 0;
}

```

## Floyd
全源最短路
时间复杂度O(N^3)
空间复杂度O(N^2)
能有负边不能有负环

```cpp
for(int k = 0; k < n; k++) { //途径k
	for(int i = 0; i < n; i++) {
		for(int j = 0; j < n; j++) {
			if(dis[i][k] != inf && dis[k][j] != inf 
			&& dis[i][k] + dis[k][j] < dis[i][j]) {
				dis[i][j] = dis[i][k] + dis[k][j];
			}
		}
	}
}
```

## SPFA
```cpp
int dis[MAXN];//dis[i]=源点s->i最短路径
bool vis[MAXN];//vis[i]表示i是否在队列
void spfa(int s){
    for(int i=1;i<=MAXN;i++){//初始化
        dis[i]=inf;
        vis[i]=false;
    }
    dis[s]=0;//源点到自身距离为0
    queue <int> q;//使用C++自带队列
    q.push(s);//源点入队
    vis[s]=true;
    while(!q.empty()){//若队列不为空
        int cur=q.front();//取出队首元素弹出
        q.pop();
        vis[u]=true;
        for(int i=head[cur];~i;i=nx[i]){//遍历
            int to=ed[i].to;//
            if(dis[cur]+ed[i].w<dis[cur]){//如果不满足三角形不等式
                dis[to]=dis[cur]+ed[i].w;//更新答案
                if(!vis[v]){//如果终点不在队列
                    q.push(to);//入队
                    vis[to]=true;
                }
            }
        }
    }
}
```
## 最小生成树

```cpp
const int MAXN = 2e5 + 1;
struct Node {
    int x,y,v;
} a[MAXN];
int fa[5001];
int find(int x) {
    if(fa[x] != x) {
        x = find(fa[x]);
    }
    return fa[x];
}
bool merge(int x,int y) {
    int fx = find(x),fy = find(y);
    if(fx != fy) {
        fa[fx] = fy;
        return true;
    } else {
        return false;
    }
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int n,m;
    cin >> n >> m;
    _rep(i,1,m) {
        cin >> a[i].x >> a[i].y >> a[i].v;
    }
    _rep(i,1,n) {
        fa[i] = i;
    }
    sort(a+1,a+m+1,[](Node a,Node b) {return a.v < b.v;});
    int cnt = 0;
    int ans = 0;
    _rep(i,1,m) {
        if(merge(a[i].x,a[i].y)) {
            cnt++;
            ans += a[i].v;
        }
    }
    if(cnt == n - 1) {
        cout<<ans;
    } else {
        cout<<"orz";
    }
    cout<<endl;
    return 0;
}
```

## 二分图匹配
## 举例机器调度 [杭电OJ 1150 Machine Schedule](https://acm.hdu.edu.cn/showproblem.php?pid=1150)
有两台机器A和B以及N个需要运行的任务。每台机器有多种不同的模式（模式0到模式n-1），而每个任务都恰好在一台机器上运行。如果它在机器A上运行，则机器A需要设置为模式ai，如果它在机器B上运行，则机器B需要设置为模式bj。每台机器上的任务可以按照任意顺序执行，但是每台机器每转换一次模式需要重启一次。请合理为每个任务安排一台机器并合理安排顺序，使得机器重启次数尽量少。开始两台机器处于模式0。
### 分析
本质上是一个求最小顶点覆盖的问题，但是注意有一个陷阱。机器初始状态为模式0，可以在输入时预处理这一种状态，直接忽略。
其余和婚配问题一样，有n个男生，有m个女生，有k组相互符合择偶条件，求最大匹配数量。用匈牙利算法可以求解。循环执行n遍dfs,如果能形成新的组合（其中包括直接组合和可能的变换），ans++。to_boy数组记录女生的目前可能配偶，vis数组非常重要，**防止在一遍dfs内反复访问** 。
### 源代码
```c++
#include <bits/stdc++.h>
using namespace std;
bool M[110][110];
int to_boy[110];
bool vis[110];
int m;
bool dfs(int cur)
{
    for (int i = 1; i < m; i++)
    {
        if(M[cur][i] && !vis[i])
        {
            vis[i] = 1;
            if(to_boy[i] == -1 || dfs(to_boy[i]))
            {
                to_boy[i] = cur;
                return true;
            }
        }
    }
    return false;
}
int main()
{
    ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    while(true)
    {
        int n, k;
        cin >> n;
        if(n == 0)
            break;
        cin >> m >> k;
        int t,x,y;
        memset(M, 0, sizeof(M));
        for (int i = 1; i <= k; i ++)
        {
            cin >> t;
            cin >> x >> y;
            if(x != 0 && y != 0)
                M[x][y] = 1;
        }
        memset(to_boy, -1, sizeof(to_boy));
        int ans = 0;
        for (int i = 1; i < n; i++)
        {
            memset(vis, 0, sizeof(vis));
            if(dfs(i))
                ans++;
        }
        cout << ans;
    }
    return 0;
}
```




# 字符串

## 字符串哈希

### 自然溢出
```cpp
mt19937_64 rng(std::chrono::steady_clock::now().time_since_epoch().count());
int base = rng();
ll hash_(string& s) {
    ll ans = 0;
    for(int i = 0; i < s.size(); i++) {
        ans = ans*base + s[i] - 'a' + 1;
    }
    return ans;
}
```

常用base: 31、131、1313、13131、131313
质数：433、499、599、1000000007
得到子串哈希O(1)
比较一个字符串中的两个子串是否相等的时间复杂度能从O(n)降低到O(1)
```cpp
mt19937_64 rng(std::chrono::steady_clock::now().time_since_epoch().count());
int base = rng();
ll hash_[n+1];
ll power[n+1];
for(int i = 0; i <= s.size(); i++) {
    power[i] = power[i-1]*base;
    hash_[i] = hash_[i-1]*base + s[i] - 'a' + 1;
}
ll hash1 = hash_[r] - hash_[l]*power[r-l+1];

```

## KMP

字符串匹配算法
求字符串$s1$中匹配的$s2$字符串
如果暴力匹配最糟糕时间复杂度$O(n*m)$
,用KMP可以降低到$O(n+m)$

构建一个nx数组存放每一位的前一位的除本身外的字串的最长前缀后缀匹配数量

```cpp
vector<int> nx(m + 1, 0);
int j = 0;
for(int i = 2,i <= m; i++) {
    while (j > 0 && s2[i - 1] != s2[j]) {
        j = nx[j];
    }
    if (s2[i - 1] == s2[j]) {
        j++;
    }
    nx[i] = j;
}
int x = 0, y = 0;
while (x < n) {
    if (s1[x] == s2[y]) {
        x++, y++;
    } else if (y > 0) {
        y = nx[y];
    } else {
        x++;
    }
    if (y == m) {
        //cout << x - y + 1 << endl;
        //y = nx[y];
    }
}
```

# 数论
## GCD
```cpp
int gcd(int a, int b) {
    return a % b == 0 ? b : gcd(b, a % b);
}
int lcm(int a,int b) {
	return a / gcd(a, b) * b;
}
```
## 快速幂

```cpp
int ksm(int a, int b) {
    int ans = 1;
    while (b != 0) {
        if (b % 2) {
            ans *= a; // ans = ans*a%p
        } // 如果要对最终结果求余，化作对每一步求余 (((a^2)%p)^(b/2))%p = (a^b)%p
        a *= a; // a = a*a%p
        b /= 2;
    }
    return ans;
}
```

## 素数筛
### 埃氏筛
先假设假设1-n所有数都是素数
从2开始筛
小于调和级数O(n*log(n))
时间复杂度O(n*log(logn))
```cpp
ll countPrimes(ll n) {
    bool vis[n + 1];
    for (int i = 0; i <= n; i++) vis[i] = false;
    for (ll i = 2; i <= n; i++) {
        if (!vis[i]) {
            for (ll j = i * i; j <= n; j += i) {
                vis[j] = true;
            }
        }
    }
    ll cnt = 0;
    for (ll i = 2; i <= n; i++) {
        if (!vis[i]) {
            cnt++;
        }
    }
    return cnt;
}

int gcd(int a, int b) {
    return a % b == 0 ? b : gcd(b, a % b);
}


```


# 数据结构

## 并查集
```cpp
int find(int x) {
    if(fa[x] != x) {
        fa[x] = find(fa[x]);
    }
    return fa[x];
}
```

```cpp
void merge(int x,int y) {
    int fx = find(x),fy = find(y);
	fa[fx] = fy;
}
```

## 单调栈
可以求序列中左边/右边第一大/小的元素位置,出栈/入栈可以获得信息

[Water Tank](https://atcoder.jp/contests/abc359/tasks/abc359_e)
#### 故事

> 有一个长长的水箱，上面等间隔地放着不同高度的木板。高桥想知道，从水箱的一端倒水时，水到达被木板隔开的每一段的时间。

#### 问题陈述

给你一个长度为 $N$ 的正整数序列： $H=(H _ 1,H _ 2,\dotsc,H _ N)$ .

有一个长度为 $N+1$ 的非负整数序列： $A=(A _ 0,A _ 1,\dotsc,A _ N)$ .最初为 $A _ 0=A _ 1=\dotsb=A _ N=0$ 。

在 $A$ 上重复进行以下运算：

1.  将 $A _ 0$ 的值增加 $1$ 。
2.  依次对 $i=1,2,\ldots,N$ 进行以下操作：
    - 如果 $A _ {i-1}\gt A _ i$ 和 $A _ {i-1}\gt H _ i$ ，则将 $A _ {i-1}$ 的值减少 1，并将 $A _ i$ 的值增加 $1$ 。

求每个 $i=1,2,\ldots,N$ 在 $A _ i\gt 0$ 第一次成立之前的运算次数。

```cpp
int main() {
    IOS;
    int n;
    cin >> n;
    ll a[n + 1], loc[n + 1];
    ll ans[n + 1];
    memset(ans, 0, sizeof(ans));
    _rep(i, 1, n) cin >> a[i];
    stack<ll> s; //递减
    _rep(i, 1, n) { // 单调栈寻找每个元素左边第一个大于等于它的元素位置
        while (!s.empty() && a[s.top()] < a[i]) {
            s.pop();
        }
        loc[i] = s.empty() ? 0 : s.top();
        s.push(i);
    }
    _rep(i, 1, n) {
        if(loc[i] == 0) {
            ans[i] = i*a[i] + 1;
        } else {
            ans[i] = ans[loc[i]] + (i - loc[i])*a[i];
        }
    }
    _rep(i, 1, n) {
        cout << ans[i] << " ";
    }
    return 0;
}
```

## 树状数组

单点修改，区间查询
```cpp
int lowbit(int x) {
    return x & -x;
}
void add(int i,int x) {
    while(i <= n) {
        a[i] += x;
        i += lowbit(i);
    }
}
int qr(int i) { // 1 ~ i
    int ans = 0;
    while(i >= 1) {
        ans += a[i];
        i -= lowbit(i);
    }
    return ans;
}
```

查询区间\[l,r]
```cpp
cout<<qr(r) - qr(l-1);
```

## 线段树
#### 建树
递归
后序遍历二叉树，建好左右子树后再存根的值为要维护的东西

#### 懒标记
新建一下数组用于存放懒信息
如果能不更新就不更新，必须更新时只往下更新一层。


线段树常见方法一览
void up(i..) : 根据子范围的查询信息，把父范围的查询信息更新正确
void down(i..) : 父范围的懒信息，往下只下发一层，给左范围、右范围，然后父范围的懒信息清空
void lazy(i..) : 当前范围被修改任务全覆盖时 或 父范围发下来的懒更新时，信息数组们如何修改
void build(l, r, i)  : 建树
void update(jobl, jobr, jobv, l, r, i) : 范围上数值的重置任务
void add(jobl, jobr, jobv, l, r, i) : 范围上数值的增加任务
int query(jobl, jobr, l, r, i) : 范围上的信息查询任务


要求区间修改，区间查询
[洛谷](https://www.luogu.com.cn/problem/P3372)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2e5+1;
int a[N];
int sum[N<<2];
int add[N<<2];

void up(int p) {
    sum[p] = sum[p << 1] + sum[p << 1 | 1];
}

void lazy(int p, int v, int n) {
    sum[p] += v * n;
    add[p] += v;
}

void build(int p, int l, int r) {
    if (l == r) {
        sum[p] = a[l];
        return;
    }
    int mid = (l + r) >> 1;
    build(p << 1, l, mid);
    build(p << 1 | 1, mid + 1, r);
    add[p] = 0;
    up(p);
}

void down(int p, int ln, int rn) {
    if (add[p] != 0) {
        lazy(p << 1, add[p], ln);
        lazy(p << 1 | 1, add[p], rn);
        add[p] = 0;
    }
}

void change(int al, int ar, int v, int p, int l, int r) {
    if (al <= l && r <= ar) {
        lazy(p, v, r - l + 1);
    } else {
        int mid = (l + r) >> 1;
        down(p, mid - l + 1, r - mid);
        if (al <= mid) {
            change(al, ar, v, p << 1, l, mid);
        }
        if (mid + 1 <= ar) {
            change(al, ar, v, p << 1 | 1, mid + 1, r);
        }
        up(p);
    }
}

int query(int ql, int qr, int p, int l, int r) {
    if (ql <= l && r <= qr) {
        return sum[p];
    }
    int mid = (l + r) >> 1;
    down(p, mid - l + 1, r - mid);
    int cnt = 0;
    if (mid >= ql) {
        cnt += query(ql, qr, p << 1, l, mid);
    }
    if (mid + 1 <= qr) {
        cnt += query(ql, qr, p << 1 | 1, mid + 1, r);
    }
    return cnt;
}

signed main() {
    int n,m;
    cin >> n >> m;
    for(int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    build(1,1,n);
    int op,x,y,v;
    for(int i = 1; i <= m; i++) {
        cin >> op;
        if(op == 1) {
            cin >> x >> y >> v;
            change(x,y,v,1,1,n);
        } else if(op == 2) {
            cin >> x >> y;
            cout<<query(x,y,1,1,n)<<endl;
        }
    }
    return 0;
}
```

要求区间重置，区间查询
add数组改为用于记录重置值的数组，新增一个bool数组来记录节点处是否要进行重置操作，
同样也是懒更新
为什么要多一个数组，因为不能用0来标记，无法区分是重置为0还是不进行重置

```cpp
void lazy(int p, int v, int n) {
    sum[p] = v * n; //+= 改为=
    change[p] = v;
    is_change[p] = true;
}
```

```cpp
void down(int p, int ln, int rn) {
    if (is_change[p]) {
        lazy(p << 1, change[p], ln);
        lazy(p << 1 | 1, change[p], rn);
        is_change[p] = 0;
    }
}
```

维护最大/小值
up()函数修改
query函数修改返回最大值

如果要同时进行区间修改和区间重置操作，则要注意优先级,reset后cnt不要忘记清零
如果后重置无视先前修改，如果重置后再修改则要进行两次更新
[洛谷](https://www.luogu.com.cn/problem/solution/P1253)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define IOS ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr)
#define endl '\n'
#define int long long 
const int N = 1e6 + 1;
int a[N];
int mx[N << 2];
int change[N << 2];
bool is_change[N << 2];
int cnt[N << 2];
#define inf 0x3f3f3f3f // 1e9
void up(int p) {
    mx[p] = max(mx[p << 1], mx[p << 1 | 1]);
}
void build(int p, int l, int r) {
    if (l == r) {
        mx[p] = a[l];
    } else {
        int mid = (l + r) >> 1;
        build(p << 1, l, mid);
        build(p << 1 | 1, mid + 1, r);
        up(p);
    }
    is_change[p] = false;
    cnt[p] = 0;
}

void addlazy(int p, int v) {
    mx[p] += v;
    cnt[p] += v;
}

void resetlazy(int p, int v) {
    mx[p] = v;
    change[p] = v;
    is_change[p] = true;
    cnt[p] = 0;
}

void down(int p) {
    if (is_change[p]) {
        resetlazy(p << 1, change[p]);
        resetlazy(p << 1 | 1, change[p]);
        is_change[p] = false;
    }
    if (cnt[p] != 0) {
        addlazy(p << 1, cnt[p]);
        addlazy(p << 1 | 1, cnt[p]);
        cnt[p] = 0;
    }
}

void add(int al, int ar, int v, int p, int l, int r) {
    if (al <= l && r <= ar) {
        addlazy(p, v);
    } else {
        down(p);
        int mid = (l + r) >> 1;
        if (mid >= al) {
            add(al, ar, v, p << 1, l, mid);
        }
        if (mid + 1 <= ar) {
            add(al, ar, v, p << 1 | 1, mid + 1, r);
        }
        up(p);
    }
}


void reset(int rl, int rr, int v, int p, int l, int r) {
    if (rl <= l && r <= rr) {
        resetlazy(p, v);
    } else {
        down(p);
        int mid = (l + r) >> 1;
        if (mid >= rl) {
            reset(rl, rr, v, p << 1, l, mid);
        }
        if (mid + 1 <= rr) {
            reset(rl, rr, v, p << 1 | 1, mid + 1, r);
        }
        up(p);
    }
}

int query(int ql, int qr, int p, int l, int r) {
    if (ql <= l && r <= qr) {
        return mx[p];
    } else {
        down(p);
        int M = LONG_LONG_MIN;
        int mid = (l + r) >> 1;
        if (mid >= ql) {
            M = max(M, query(ql, qr, p << 1, l, mid));
        }
        if (mid + 1 <= qr) {
            M = max(M, query(ql, qr, p << 1 | 1, mid + 1, r));
        }
        return M;
    }
}
signed main() {
    IOS;
    int n, q;
    cin >> n >> q;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    build(1, 1, n);
    int op, l, r, x;
    for (int i = 1; i <= q; i++) {
        cin >> op;
        if (op == 1) {
            cin >> l >> r >> x;
            reset(l, r, x, 1, 1, n);
        } else if (op == 2) {
            cin >> l >> r >> x;
            add(l, r, x, 1, 1, n);
        } else if (op == 3) {
            cin >> l >> r;
            cout << query(l, r, 1, 1, n) << endl;
        }
    }
    return 0;
}

/**
 * author:  Egrvigrf
 * created: 2024-07-23 13:54
**/
```


# DP
## 背包DP

### 01背包
每种物品只能选择一次,设有$n$种物品，每种物品的价值为$w_i$，体积为$v_i$，背包的容量为$V$。
`ans[i][j]`代表有前$i$个物品，空间为j时的价值最大值。
取选第$i$个物品与不选第$i$个物品的较大值。

```c++
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= V; j++) {
        if (j < v[i]) { 
            ans[i][j] = ans[i - 1][j];
        } else { 
            ans[i][j] = max(ans[i - 1][j], ans[i - 1][j - v[i]] + w[i]); 
        }
    }
}

滚动数组压缩空间
**从后往前**更新
```c++
for(int i = 1; i <= n; i++) {
    for(int j = V; j >= v[i]; j--) {
        ans[j] = max(ans[j],ans[j-v[i]] + w[i]);
    }
}
```
### 完全背包
每种物品可以取任意次。
转移方程和01背包类似
```c++
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= V; j++) {
        if (j < v[i]) { 
            ans[i][j] = ans[i - 1][j];
        } else { 
            ans[i][j] = max(ans[i - 1][j], ans[i][j - v[i]] + w[i]); 
        }
    }
}
```

滚动数组压缩空间
**从前往后**更新
```c++
for(int i = 1; i <= n; i++) {
    for(int j = v[i]; j <= V; j++) {
        ans[j] = max(ans[j],ans[j-v[i]] + w[i]);
    }
}
```


### n维背包
有多个考虑因素
以二维01背包为例，增加条件背包最大承重为$M$，每一件物品的质量为$m_i$。
```c++
for (int i = 1; i <= n; i++)//放置第i件物品
{
    for (int j = 1; j <= V; j++)//j为当前体积
    {
        for (int k = 1; k <= M; k++)//k为当前质量
        {
            if (j - v[i] < 0 || k - m[i] < 0) { //任意一种条件不满足就放不进去
                a[i][j][k] = a[i - 1][j][k];
            } else {
                a[i][j][k] = max(a[i - 1][j][k], a[i - 1][j - v[i]][k - m[i]] + c[i]);
            }
        }
    }
}
```

滚动数组压缩空间
```c++
for (int i = 1; i <= n; i++) {
    for (int j = V; j >= v[i]; j--) { // j为当前体积
        for (int k = M; k >= m[i]; k--) { // k为当前质量
            b[j][k] = max(b[j][k], b[j - v[i]][k - m[i]] + c[i]);
        }
    }
}
```


